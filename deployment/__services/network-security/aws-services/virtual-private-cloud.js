"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createVpc = void 0;
const aws_ec2_1 = require("aws-cdk-lib/aws-ec2");
const cdk_fck_nat_1 = require("cdk-fck-nat");
const createVpc = (scope, props) => {
    const { freeTier = true } = props;
    if (freeTier) {
        return new aws_ec2_1.Vpc(scope, props.identifier, {
            maxAzs: 2,
            natGateways: 0,
            subnetConfiguration: [publicSubnet],
            ...props.overrides,
        });
    }
    return new aws_ec2_1.Vpc(scope, props.identifier, {
        // fckNat saves a ton of money.
        // see: https://github.com/AndrewGuenther/fck-nat
        natGatewayProvider: new cdk_fck_nat_1.FckNatInstanceProvider({
            instanceType: new aws_ec2_1.InstanceType('t4g.nano'),
        }),
        // By default, we don't get an isolated subnet.
        // in most instances, we probably want one(for RDS).
        // In certain instances, we can avoid NAT gateways by utilizing
        // an isolated subnet
        subnetConfiguration: [publicSubnet, privateSubnet, isolatedSubnet],
    });
};
exports.createVpc = createVpc;
const publicSubnet = {
    subnetType: aws_ec2_1.SubnetType.PUBLIC,
    name: 'Public',
    cidrMask: 24,
};
const privateSubnet = {
    subnetType: aws_ec2_1.SubnetType.PRIVATE_WITH_EGRESS,
    name: 'Private',
    cidrMask: 24,
};
const isolatedSubnet = {
    cidrMask: 28,
    name: 'Isolated',
    subnetType: aws_ec2_1.SubnetType.PRIVATE_ISOLATED,
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmlydHVhbC1wcml2YXRlLWNsb3VkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsidmlydHVhbC1wcml2YXRlLWNsb3VkLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLGlEQUE2RTtBQUU3RSw2Q0FBb0Q7QUFzQjdDLE1BQU0sU0FBUyxHQUFHLENBQUMsS0FBZ0IsRUFBRSxLQUFZLEVBQUUsRUFBRTtJQUMxRCxNQUFNLEVBQUUsUUFBUSxHQUFHLElBQUksRUFBRSxHQUFHLEtBQUssQ0FBQTtJQUNqQyxJQUFJLFFBQVEsRUFBRTtRQUNaLE9BQU8sSUFBSSxhQUFHLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxVQUFVLEVBQUU7WUFDdEMsTUFBTSxFQUFFLENBQUM7WUFDVCxXQUFXLEVBQUUsQ0FBQztZQUNkLG1CQUFtQixFQUFFLENBQUMsWUFBWSxDQUFDO1lBQ25DLEdBQUcsS0FBSyxDQUFDLFNBQVM7U0FDbkIsQ0FBQyxDQUFBO0tBQ0g7SUFFRCxPQUFPLElBQUksYUFBRyxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsVUFBVSxFQUFFO1FBQ3RDLCtCQUErQjtRQUMvQixpREFBaUQ7UUFDakQsa0JBQWtCLEVBQUUsSUFBSSxvQ0FBc0IsQ0FBQztZQUM3QyxZQUFZLEVBQUUsSUFBSSxzQkFBWSxDQUFDLFVBQVUsQ0FBQztTQUMzQyxDQUFDO1FBQ0YsK0NBQStDO1FBQy9DLG9EQUFvRDtRQUNwRCwrREFBK0Q7UUFDL0QscUJBQXFCO1FBQ3JCLG1CQUFtQixFQUFFLENBQUMsWUFBWSxFQUFFLGFBQWEsRUFBRSxjQUFjLENBQUM7S0FDbkUsQ0FBQyxDQUFBO0FBQ0osQ0FBQyxDQUFBO0FBdkJZLFFBQUEsU0FBUyxhQXVCckI7QUFFRCxNQUFNLFlBQVksR0FBRztJQUNuQixVQUFVLEVBQUUsb0JBQVUsQ0FBQyxNQUFNO0lBQzdCLElBQUksRUFBRSxRQUFRO0lBQ2QsUUFBUSxFQUFFLEVBQUU7Q0FDYixDQUFBO0FBQ0QsTUFBTSxhQUFhLEdBQUc7SUFDcEIsVUFBVSxFQUFFLG9CQUFVLENBQUMsbUJBQW1CO0lBQzFDLElBQUksRUFBRSxTQUFTO0lBQ2YsUUFBUSxFQUFFLEVBQUU7Q0FDYixDQUFBO0FBQ0QsTUFBTSxjQUFjLEdBQUc7SUFDckIsUUFBUSxFQUFFLEVBQUU7SUFDWixJQUFJLEVBQUUsVUFBVTtJQUNoQixVQUFVLEVBQUUsb0JBQVUsQ0FBQyxnQkFBZ0I7Q0FDeEMsQ0FBQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluc3RhbmNlVHlwZSwgU3VibmV0VHlwZSwgVnBjLCBWcGNQcm9wcyB9IGZyb20gJ2F3cy1jZGstbGliL2F3cy1lYzInXG5pbXBvcnQgeyBDb25zdHJ1Y3QgfSBmcm9tICdjb25zdHJ1Y3RzJ1xuaW1wb3J0IHsgRmNrTmF0SW5zdGFuY2VQcm92aWRlciB9IGZyb20gJ2Nkay1mY2stbmF0J1xuXG50eXBlIFByb3BzID0ge1xuICBpZGVudGlmaWVyOiBzdHJpbmdcbiAgLyoqXG4gICAqIEluZGljYXRlcyB0aGF0IHRoZXJlIHNob3VsZCBvbmx5IGJlIGEgc2luZ2xlLCBwdWJsaWMgc3VibmV0IGluIHRoaXMgVlBDXG4gICAqIElmIHlvdSB3YW50IGl0IHRvIGJlIGZyZWUsIHRoaXMgbXVzdCBiZSB0cnVlLiBPdGhlcndpc2UsIHlvdXIgc2hpdCBpbiBwcml2YXRlIHN1Ym5ldHMgd29uJ3QgYmUgYWJsZVxuICAgKiB0byB0YWxrIHRvIGVhY2ggb3RoZXIgd2l0aG91dCBhIE5BVCBnYXRld2F5IG9yIFZQQyBlbmRwb2ludHMuXG4gICAqIEJvdGggb2YgdGhvc2UgdGhpbmdzIGNvc3QgbW9uZXkoZXZlbiBmb3IgZnJlZSB0aWVyIGFjY291bnRzKS5cbiAgICogTk9URTogIFNlY3VyaXR5IEdyb3VwcyBhbGxvdyB5b3UgdG8gbGltaXQgYWNjZXNzIHRvIHlvdXIgcmVzb3VyY2VzLlxuICAgKiBiZWNhdXNlIHlvdSBhcmUgbm90IHV0aWxpemluZyBzdWJuZXRzLCB5b3UgKm11c3QqIGNvbmZpZ3VyZSB0aGVtIGFkZXF1YXRlbHkuXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGZyZWVUaWVyPzogYm9vbGVhblxuXG4gIC8qKlxuICAgIE5vcm1hbCBDREsgcHJvcHMgZm9yIGNvbmZpZ3VyaW5nIGEgVlBDXG4gICAgQGRlZmF1bHQgdW5kZWZpbmVkXG4gICovXG4gIG92ZXJyaWRlcz86IFZwY1Byb3BzXG59XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVWcGMgPSAoc2NvcGU6IENvbnN0cnVjdCwgcHJvcHM6IFByb3BzKSA9PiB7XG4gIGNvbnN0IHsgZnJlZVRpZXIgPSB0cnVlIH0gPSBwcm9wc1xuICBpZiAoZnJlZVRpZXIpIHtcbiAgICByZXR1cm4gbmV3IFZwYyhzY29wZSwgcHJvcHMuaWRlbnRpZmllciwge1xuICAgICAgbWF4QXpzOiAyLCAvLyBJbiBvcmRlciBmb3IgUkRTIHRvIHdvcmsgY29ycmVjdGx5LCB3ZSBuZWVkIGEgbWluaW11bSBvZiAyIEFaJ3NcbiAgICAgIG5hdEdhdGV3YXlzOiAwLFxuICAgICAgc3VibmV0Q29uZmlndXJhdGlvbjogW3B1YmxpY1N1Ym5ldF0sXG4gICAgICAuLi5wcm9wcy5vdmVycmlkZXMsXG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiBuZXcgVnBjKHNjb3BlLCBwcm9wcy5pZGVudGlmaWVyLCB7XG4gICAgLy8gZmNrTmF0IHNhdmVzIGEgdG9uIG9mIG1vbmV5LlxuICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL0FuZHJld0d1ZW50aGVyL2Zjay1uYXRcbiAgICBuYXRHYXRld2F5UHJvdmlkZXI6IG5ldyBGY2tOYXRJbnN0YW5jZVByb3ZpZGVyKHtcbiAgICAgIGluc3RhbmNlVHlwZTogbmV3IEluc3RhbmNlVHlwZSgndDRnLm5hbm8nKSxcbiAgICB9KSxcbiAgICAvLyBCeSBkZWZhdWx0LCB3ZSBkb24ndCBnZXQgYW4gaXNvbGF0ZWQgc3VibmV0LlxuICAgIC8vIGluIG1vc3QgaW5zdGFuY2VzLCB3ZSBwcm9iYWJseSB3YW50IG9uZShmb3IgUkRTKS5cbiAgICAvLyBJbiBjZXJ0YWluIGluc3RhbmNlcywgd2UgY2FuIGF2b2lkIE5BVCBnYXRld2F5cyBieSB1dGlsaXppbmdcbiAgICAvLyBhbiBpc29sYXRlZCBzdWJuZXRcbiAgICBzdWJuZXRDb25maWd1cmF0aW9uOiBbcHVibGljU3VibmV0LCBwcml2YXRlU3VibmV0LCBpc29sYXRlZFN1Ym5ldF0sXG4gIH0pXG59XG5cbmNvbnN0IHB1YmxpY1N1Ym5ldCA9IHtcbiAgc3VibmV0VHlwZTogU3VibmV0VHlwZS5QVUJMSUMsXG4gIG5hbWU6ICdQdWJsaWMnLFxuICBjaWRyTWFzazogMjQsXG59XG5jb25zdCBwcml2YXRlU3VibmV0ID0ge1xuICBzdWJuZXRUeXBlOiBTdWJuZXRUeXBlLlBSSVZBVEVfV0lUSF9FR1JFU1MsXG4gIG5hbWU6ICdQcml2YXRlJyxcbiAgY2lkck1hc2s6IDI0LFxufVxuY29uc3QgaXNvbGF0ZWRTdWJuZXQgPSB7XG4gIGNpZHJNYXNrOiAyOCxcbiAgbmFtZTogJ0lzb2xhdGVkJyxcbiAgc3VibmV0VHlwZTogU3VibmV0VHlwZS5QUklWQVRFX0lTT0xBVEVELFxufVxuIl19