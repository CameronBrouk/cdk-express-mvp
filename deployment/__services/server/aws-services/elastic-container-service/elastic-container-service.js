"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBaseService = void 0;
const aws_ec2_1 = require("aws-cdk-lib/aws-ec2");
const aws_ecs_1 = require("aws-cdk-lib/aws-ecs");
const createBaseService = (scope, props) => {
    const ec2GroupCapacityProvider = new aws_ecs_1.AsgCapacityProvider(scope, 'GroupCapacityProvider', {
        autoScalingGroup: props.autoScalingGroup,
        canContainersAccessInstanceRole: true,
        enableManagedTerminationProtection: false,
    });
    // We must add a capacity provider to the cluster in order to make it work with an ec2 autoscaling group
    props.cluster.addAsgCapacityProvider(ec2GroupCapacityProvider);
    const ecsService = new aws_ecs_1.Ec2Service(scope, 'EcsService', {
        cluster: props.cluster,
        taskDefinition: props.taskDefinition,
        // If we are using an autoscaling group, we need to do this.
        propagateTags: aws_ecs_1.PropagatedTagSource.TASK_DEFINITION,
        capacityProviderStrategies: [
            {
                capacityProvider: ec2GroupCapacityProvider.capacityProviderName,
                base: 1,
                weight: 100, // If you do not include a weight when using a capacity provider, CDK will error
            },
        ],
        // Only run one task / ec2 instance. i.e. each ec2 instance acts as it's own application
        // Note:  On deployments, we will deploy another ec2 instance for a moment(adding costs), but it will replace the previous instance
        daemon: true,
        deploymentController: {
            type: aws_ecs_1.DeploymentControllerType.ECS,
        },
        securityGroups: [props.ecsSecurityGroup],
        vpcSubnets: { subnetType: aws_ec2_1.SubnetType.PUBLIC },
    });
    return {
        ecsService,
        ec2GroupCapacityProvider,
    };
};
exports.createBaseService = createBaseService;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWxhc3RpYy1jb250YWluZXItc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImVsYXN0aWMtY29udGFpbmVyLXNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQ0EsaURBQStEO0FBQy9ELGlEQU80QjtBQUdyQixNQUFNLGlCQUFpQixHQUFHLENBQy9CLEtBQWdCLEVBQ2hCLEtBS0MsRUFDRCxFQUFFO0lBQ0YsTUFBTSx3QkFBd0IsR0FBRyxJQUFJLDZCQUFtQixDQUN0RCxLQUFLLEVBQ0wsdUJBQXVCLEVBQ3ZCO1FBQ0UsZ0JBQWdCLEVBQUUsS0FBSyxDQUFDLGdCQUFnQjtRQUN4QywrQkFBK0IsRUFBRSxJQUFJO1FBQ3JDLGtDQUFrQyxFQUFFLEtBQUs7S0FDMUMsQ0FDRixDQUFBO0lBRUQsd0dBQXdHO0lBQ3hHLEtBQUssQ0FBQyxPQUFPLENBQUMsc0JBQXNCLENBQUMsd0JBQXdCLENBQUMsQ0FBQTtJQUU5RCxNQUFNLFVBQVUsR0FBRyxJQUFJLG9CQUFVLENBQUMsS0FBSyxFQUFFLFlBQVksRUFBRTtRQUNyRCxPQUFPLEVBQUUsS0FBSyxDQUFDLE9BQU87UUFDdEIsY0FBYyxFQUFFLEtBQUssQ0FBQyxjQUFjO1FBQ3BDLDREQUE0RDtRQUM1RCxhQUFhLEVBQUUsNkJBQW1CLENBQUMsZUFBZTtRQUNsRCwwQkFBMEIsRUFBRTtZQUMxQjtnQkFDRSxnQkFBZ0IsRUFBRSx3QkFBd0IsQ0FBQyxvQkFBb0I7Z0JBQy9ELElBQUksRUFBRSxDQUFDO2dCQUNQLE1BQU0sRUFBRSxHQUFHLEVBQUUsZ0ZBQWdGO2FBQzlGO1NBQ0Y7UUFDRCx3RkFBd0Y7UUFDeEYsbUlBQW1JO1FBQ25JLE1BQU0sRUFBRSxJQUFJO1FBQ1osb0JBQW9CLEVBQUU7WUFDcEIsSUFBSSxFQUFFLGtDQUF3QixDQUFDLEdBQUc7U0FDbkM7UUFDRCxjQUFjLEVBQUUsQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUM7UUFDeEMsVUFBVSxFQUFFLEVBQUUsVUFBVSxFQUFFLG9CQUFVLENBQUMsTUFBTSxFQUFFO0tBQzlDLENBQUMsQ0FBQTtJQUVGLE9BQU87UUFDTCxVQUFVO1FBQ1Ysd0JBQXdCO0tBQ3pCLENBQUE7QUFDSCxDQUFDLENBQUE7QUFoRFksUUFBQSxpQkFBaUIscUJBZ0Q3QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEF1dG9TY2FsaW5nR3JvdXAgfSBmcm9tICdhd3MtY2RrLWxpYi9hd3MtYXV0b3NjYWxpbmcnXG5pbXBvcnQgeyBTZWN1cml0eUdyb3VwLCBTdWJuZXRUeXBlIH0gZnJvbSAnYXdzLWNkay1saWIvYXdzLWVjMidcbmltcG9ydCB7XG4gIEFzZ0NhcGFjaXR5UHJvdmlkZXIsXG4gIENsdXN0ZXIsXG4gIERlcGxveW1lbnRDb250cm9sbGVyVHlwZSxcbiAgRWMyU2VydmljZSxcbiAgUHJvcGFnYXRlZFRhZ1NvdXJjZSxcbiAgVGFza0RlZmluaXRpb24sXG59IGZyb20gJ2F3cy1jZGstbGliL2F3cy1lY3MnXG5pbXBvcnQgeyBDb25zdHJ1Y3QgfSBmcm9tICdjb25zdHJ1Y3RzJ1xuXG5leHBvcnQgY29uc3QgY3JlYXRlQmFzZVNlcnZpY2UgPSAoXG4gIHNjb3BlOiBDb25zdHJ1Y3QsXG4gIHByb3BzOiB7XG4gICAgYXV0b1NjYWxpbmdHcm91cDogQXV0b1NjYWxpbmdHcm91cFxuICAgIGVjc1NlY3VyaXR5R3JvdXA6IFNlY3VyaXR5R3JvdXBcbiAgICBjbHVzdGVyOiBDbHVzdGVyXG4gICAgdGFza0RlZmluaXRpb246IFRhc2tEZWZpbml0aW9uXG4gIH0sXG4pID0+IHtcbiAgY29uc3QgZWMyR3JvdXBDYXBhY2l0eVByb3ZpZGVyID0gbmV3IEFzZ0NhcGFjaXR5UHJvdmlkZXIoXG4gICAgc2NvcGUsXG4gICAgJ0dyb3VwQ2FwYWNpdHlQcm92aWRlcicsXG4gICAge1xuICAgICAgYXV0b1NjYWxpbmdHcm91cDogcHJvcHMuYXV0b1NjYWxpbmdHcm91cCxcbiAgICAgIGNhbkNvbnRhaW5lcnNBY2Nlc3NJbnN0YW5jZVJvbGU6IHRydWUsXG4gICAgICBlbmFibGVNYW5hZ2VkVGVybWluYXRpb25Qcm90ZWN0aW9uOiBmYWxzZSxcbiAgICB9LFxuICApXG5cbiAgLy8gV2UgbXVzdCBhZGQgYSBjYXBhY2l0eSBwcm92aWRlciB0byB0aGUgY2x1c3RlciBpbiBvcmRlciB0byBtYWtlIGl0IHdvcmsgd2l0aCBhbiBlYzIgYXV0b3NjYWxpbmcgZ3JvdXBcbiAgcHJvcHMuY2x1c3Rlci5hZGRBc2dDYXBhY2l0eVByb3ZpZGVyKGVjMkdyb3VwQ2FwYWNpdHlQcm92aWRlcilcblxuICBjb25zdCBlY3NTZXJ2aWNlID0gbmV3IEVjMlNlcnZpY2Uoc2NvcGUsICdFY3NTZXJ2aWNlJywge1xuICAgIGNsdXN0ZXI6IHByb3BzLmNsdXN0ZXIsXG4gICAgdGFza0RlZmluaXRpb246IHByb3BzLnRhc2tEZWZpbml0aW9uLFxuICAgIC8vIElmIHdlIGFyZSB1c2luZyBhbiBhdXRvc2NhbGluZyBncm91cCwgd2UgbmVlZCB0byBkbyB0aGlzLlxuICAgIHByb3BhZ2F0ZVRhZ3M6IFByb3BhZ2F0ZWRUYWdTb3VyY2UuVEFTS19ERUZJTklUSU9OLFxuICAgIGNhcGFjaXR5UHJvdmlkZXJTdHJhdGVnaWVzOiBbXG4gICAgICB7XG4gICAgICAgIGNhcGFjaXR5UHJvdmlkZXI6IGVjMkdyb3VwQ2FwYWNpdHlQcm92aWRlci5jYXBhY2l0eVByb3ZpZGVyTmFtZSxcbiAgICAgICAgYmFzZTogMSwgLy8gaWYgeW91IGRvIG5vdCBpbmNsdWRlIGEgYmFzZSB3aGVuIHVzaW5nIGEgY2FwYWNpdHkgcHJvdmlkZXIsIENESyB3aWxsIGVycm9yXG4gICAgICAgIHdlaWdodDogMTAwLCAvLyBJZiB5b3UgZG8gbm90IGluY2x1ZGUgYSB3ZWlnaHQgd2hlbiB1c2luZyBhIGNhcGFjaXR5IHByb3ZpZGVyLCBDREsgd2lsbCBlcnJvclxuICAgICAgfSxcbiAgICBdLFxuICAgIC8vIE9ubHkgcnVuIG9uZSB0YXNrIC8gZWMyIGluc3RhbmNlLiBpLmUuIGVhY2ggZWMyIGluc3RhbmNlIGFjdHMgYXMgaXQncyBvd24gYXBwbGljYXRpb25cbiAgICAvLyBOb3RlOiAgT24gZGVwbG95bWVudHMsIHdlIHdpbGwgZGVwbG95IGFub3RoZXIgZWMyIGluc3RhbmNlIGZvciBhIG1vbWVudChhZGRpbmcgY29zdHMpLCBidXQgaXQgd2lsbCByZXBsYWNlIHRoZSBwcmV2aW91cyBpbnN0YW5jZVxuICAgIGRhZW1vbjogdHJ1ZSxcbiAgICBkZXBsb3ltZW50Q29udHJvbGxlcjoge1xuICAgICAgdHlwZTogRGVwbG95bWVudENvbnRyb2xsZXJUeXBlLkVDUyxcbiAgICB9LFxuICAgIHNlY3VyaXR5R3JvdXBzOiBbcHJvcHMuZWNzU2VjdXJpdHlHcm91cF0sXG4gICAgdnBjU3VibmV0czogeyBzdWJuZXRUeXBlOiBTdWJuZXRUeXBlLlBVQkxJQyB9LFxuICB9KVxuXG4gIHJldHVybiB7XG4gICAgZWNzU2VydmljZSxcbiAgICBlYzJHcm91cENhcGFjaXR5UHJvdmlkZXIsXG4gIH1cbn1cbiJdfQ==